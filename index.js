const express = require('express');
const line = require('@line/bot-sdk');
const admin = require('firebase-admin');
const fuzzysort = require('fuzzysort');

const app = express();

// LINE Bot configuration
const config = {
  channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.CHANNEL_SECRET,
};

const client = new line.Client(config);

// Firebase configuration - ‡πÉ‡∏ä‡πâ variables ‡πÅ‡∏¢‡∏Å‡∏Å‡∏±‡∏ô
console.log('Initializing Firebase...');

// ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö environment variables
const requiredEnvVars = [
  'CHANNEL_ACCESS_TOKEN',
  'CHANNEL_SECRET',
  'FIREBASE_PROJECT_ID',
  'FIREBASE_PRIVATE_KEY',
  'FIREBASE_CLIENT_EMAIL',
  'FIREBASE_CLIENT_ID',
  'FIREBASE_PRIVATE_KEY_ID',
  'FIREBASE_CLIENT_CERT_URL'
];

const missingVars = requiredEnvVars.filter(varName => !process.env[varName]);
if (missingVars.length > 0) {
  console.error('‚ùå Missing required environment variables:', missingVars);
  process.exit(1);
}

// ‡∏™‡∏£‡πâ‡∏≤‡∏á service account object
const serviceAccount = {
  type: "service_account",
  project_id: process.env.FIREBASE_PROJECT_ID,
  private_key_id: process.env.FIREBASE_PRIVATE_KEY_ID,
  // ‡πÅ‡∏õ‡∏•‡∏á \\n ‡πÄ‡∏õ‡πá‡∏ô newline ‡∏à‡∏£‡∏¥‡∏á ‡πÅ‡∏•‡∏∞‡∏•‡∏ö quotes ‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏à‡∏∞‡∏ï‡∏¥‡∏î‡∏°‡∏≤
  private_key: process.env.FIREBASE_PRIVATE_KEY
    .replace(/\\n/g, '\n')
    .replace(/^"/, '')
    .replace(/"$/, ''),
  client_email: process.env.FIREBASE_CLIENT_EMAIL,
  client_id: process.env.FIREBASE_CLIENT_ID,
  auth_uri: "https://accounts.google.com/o/oauth2/auth",
  token_uri: "https://oauth2.googleapis.com/token",
  auth_provider_x509_cert_url: "https://www.googleapis.com/oauth2/v1/certs",
  client_x509_cert_url: process.env.FIREBASE_CLIENT_CERT_URL
};

console.log('‚úÖ Service account configured');
console.log('üìß Client email:', serviceAccount.client_email);
console.log('üîë Project ID:', serviceAccount.project_id);
console.log('üîê Private key length:', serviceAccount.private_key.length);

// Initialize Firebase Admin
let db;
try {
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    databaseURL: `https://${serviceAccount.project_id}-default-rtdb.asia-southeast1.firebasedatabase.app/`
  });
  db = admin.firestore();
  console.log('‚úÖ Firebase initialized successfully');
} catch (error) {
  console.error('‚ùå Firebase initialization error:', error.message);
  console.error('Full error:', error);
  process.exit(1);
}

// Test Firestore connection
async function testFirestoreConnection() {
  try {
    console.log('üîç Testing Firestore connection...');
    
    const preferencesSnapshot = await db.collection('preferences').get();
    console.log('üìÑ Documents in preferences collection:', preferencesSnapshot.size);
    
    const docNames = [];
    preferencesSnapshot.forEach(doc => {
      docNames.push(doc.id);
    });
    console.log('üìã Document names:', docNames);
    
    console.log('‚úÖ Firestore connection successful');
    
  } catch (error) {
    console.error('‚ùå Firestore connection failed:', error.message);
    console.error('Error code:', error.code);
  }
}

// Initialize connection test (non-blocking)
setTimeout(() => {
  testFirestoreConnection();
}, 1000);

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏Ñ‡∏ô‡πÉ‡∏ô‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°
function detectPersonInQuestion(question) {
  if (!question || typeof question !== 'string') {
    return 'both';
  }
  
  const lowerQuestion = question.toLowerCase();
  
  const fernKeywords = ['‡πÄ‡∏ü‡∏¥‡∏£‡πå‡∏ô', 'fern', '‡πÄ‡∏ü‡∏¥', '‡πÄ‡∏ü‡∏¥‡πà‡∏ô'];
  const nannamKeywords = ['‡∏ô‡πà‡∏≤‡∏ô‡∏ô‡πâ‡∏≥', 'nannam', '‡∏ô‡∏≤‡∏ô‡∏≤‡∏°', '‡∏ô‡πà‡∏≤‡∏ô', '‡∏ô‡∏≤‡∏ô'];
  
  const hasFernKeyword = fernKeywords.some(keyword => 
    lowerQuestion.includes(keyword.toLowerCase())
  );
  
  const hasNannamKeyword = nannamKeywords.some(keyword => 
    lowerQuestion.includes(keyword.toLowerCase())
  );
  
  if (hasFernKeyword && !hasNannamKeyword) {
    return 'fern';
  } else if (hasNannamKeyword && !hasFernKeyword) {
    return 'nannam';
  } else {
    return 'both';
  }
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ó‡∏≥‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°
function cleanQuestion(question) {
  if (!question || typeof question !== 'string') {
    return '';
  }
  
  const fernKeywords = ['‡πÄ‡∏ü‡∏¥‡∏£‡πå‡∏ô', 'fern', '‡πÄ‡∏ü‡∏¥', '‡πÄ‡∏ü‡∏¥‡πà‡∏ô'];
  const nannamKeywords = ['‡∏ô‡πà‡∏≤‡∏ô‡∏ô‡πâ‡∏≥', 'nannam', '‡∏ô‡∏≤‡∏ô‡∏≤‡∏°', '‡∏ô‡πà‡∏≤‡∏ô', '‡∏ô‡∏≤‡∏ô'];
  
  let cleanedQuestion = question;
  
  [...fernKeywords, ...nannamKeywords].forEach(name => {
    const regex = new RegExp(name, 'gi');
    cleanedQuestion = cleanedQuestion.replace(regex, '').trim();
  });
  
  cleanedQuestion = cleanedQuestion.replace(/\s+/g, ' ').trim();
  return cleanedQuestion;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡πÅ‡∏¢‡∏Å‡∏Ñ‡∏≥‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏à‡∏≤‡∏Å‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°
function extractKeywords(question) {
  if (!question || typeof question !== 'string') {
    return [];
  }
  
  // ‡∏•‡∏ö‡∏Ñ‡∏≥‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
  const stopWords = [
    '‡∏≠‡∏∞‡πÑ‡∏£', '‡πÑ‡∏´‡∏ô', '‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏´‡∏£‡πà', '‡∏¢‡∏±‡∏á‡πÑ‡∏á', '‡∏ó‡∏≥‡πÑ‡∏°', '‡πÉ‡∏Ñ‡∏£', '‡πÑ‡∏´‡∏°', '‡∏´‡∏£‡∏∑‡∏≠', '‡πÅ‡∏•‡πâ‡∏ß',
    '‡∏Ñ‡∏£‡∏±‡∏ö', '‡∏Ñ‡πà‡∏∞', '‡∏ô‡∏∞', '‡∏≠‡πà‡∏∞', '‡πÄ‡∏≠‡πà‡∏≠', '‡∏≠‡∏∑‡∏°', '‡πÄ‡∏≠‡∏≠', '‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö', '‡∏ô‡∏∞‡∏Ñ‡∏∞',
    '‡∏Ñ‡∏∑‡∏≠', '‡πÅ‡∏ö‡∏ö', '‡∏û‡∏≠', '‡∏à‡∏±‡∏á', '‡∏°‡∏≤‡∏Å', '‡πÄ‡∏•‡∏¢', '‡∏™‡∏∏‡∏î', '‡πÑ‡∏î‡πâ', '‡∏°‡∏±‡πâ‡∏¢', '‡πÑ‡∏á'
  ];
  
  // ‡πÅ‡∏¢‡∏Å‡∏Ñ‡∏≥‡πÅ‡∏•‡∏∞‡∏•‡∏ö stop words
  let words = question.split(/\s+/).filter(word => {
    word = word.toLowerCase().replace(/[^\u0E00-\u0E7Fa-zA-Z]/g, '');
    return word.length > 0 && !stopWords.includes(word);
  });
  
  return words;
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Ñ‡∏•‡∏∂‡∏á‡πÅ‡∏ö‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏°‡∏¥‡∏ï‡∏¥
function calculateSimilarity(question, data) {
  if (!question || typeof question !== 'string' || !data) {
    return { score: -Infinity, details: [] };
  }
  
  const questionKeywords = extractKeywords(question.toLowerCase());
  console.log('üîç Question keywords:', questionKeywords);
  
  let bestScore = -Infinity;
  let matchDetails = [];
  
  // 1. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö exact match ‡πÉ‡∏ô question
  if (data.question && typeof data.question === 'string') {
    const exactMatch = questionKeywords.some(keyword => 
      data.question.toLowerCase().includes(keyword)
    );
    if (exactMatch) {
      bestScore = Math.max(bestScore, 1000);
      matchDetails.push('exact_question_match');
    }
    
    // fuzzy match ‡∏Å‡∏±‡∏ö question
    try {
      const fuzzyResult = fuzzysort.single(question, data.question);
      if (fuzzyResult) {
        bestScore = Math.max(bestScore, fuzzyResult.score + 500);
        matchDetails.push(`fuzzy_question: ${fuzzyResult.score}`);
      }
    } catch (error) {
      console.warn('Fuzzy search error:', error.message);
    }
  }
  
  // 2. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö keywords array
  if (data.keywords && Array.isArray(data.keywords)) {
    data.keywords.forEach((keyword, index) => {
      if (typeof keyword !== 'string') return;
      
      // exact keyword match
      const exactKeywordMatch = questionKeywords.some(qKeyword => 
        keyword.toLowerCase().includes(qKeyword) || qKeyword.includes(keyword.toLowerCase())
      );
      
      if (exactKeywordMatch) {
        bestScore = Math.max(bestScore, 800);
        matchDetails.push(`exact_keyword[${index}]: ${keyword}`);
      }
      
      // fuzzy keyword match
      try {
        const fuzzyKeywordResult = fuzzysort.single(question, keyword);
        if (fuzzyKeywordResult && fuzzyKeywordResult.score > -2000) {
          bestScore = Math.max(bestScore, fuzzyKeywordResult.score + 300);
          matchDetails.push(`fuzzy_keyword[${index}]: ${fuzzyKeywordResult.score}`);
        }
      } catch (error) {
        console.warn('Fuzzy keyword search error:', error.message);
      }
      
      // partial keyword match
      questionKeywords.forEach(qKeyword => {
        if (qKeyword.length > 2 && keyword.toLowerCase().includes(qKeyword)) {
          bestScore = Math.max(bestScore, 600);
          matchDetails.push(`partial_keyword[${index}]: ${qKeyword} in ${keyword}`);
        }
      });
    });
  }
  
  // 3. ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏Ñ‡∏•‡∏∂‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≥‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Ñ‡∏≥
  questionKeywords.forEach(qKeyword => {
    if (data.question && typeof data.question === 'string') {
      const questionWords = extractKeywords(data.question);
      questionWords.forEach(dataWord => {
        if (qKeyword.length > 2 && dataWord.length > 2) {
          // ‡πÄ‡∏ä‡πá‡∏Ñ substring match
          if (qKeyword.includes(dataWord) || dataWord.includes(qKeyword)) {
            bestScore = Math.max(bestScore, 400);
            matchDetails.push(`word_similarity: ${qKeyword} ~ ${dataWord}`);
          }
          
          // ‡πÄ‡∏ä‡πá‡∏Ñ edit distance (simple)
          if (Math.abs(qKeyword.length - dataWord.length) <= 2) {
            let commonChars = 0;
            for (let i = 0; i < Math.min(qKeyword.length, dataWord.length); i++) {
              if (qKeyword[i] === dataWord[i]) commonChars++;
            }
            if (commonChars >= Math.min(qKeyword.length, dataWord.length) * 0.6) {
              bestScore = Math.max(bestScore, 300);
              matchDetails.push(`char_similarity: ${qKeyword} ~ ${dataWord}`);
            }
          }
        }
      });
    }
  });
  
  return { score: bestScore, details: matchDetails };
}

// ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á findAnswer ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
async function findAnswer(originalQuestion) {
  try {
    if (!originalQuestion || typeof originalQuestion !== 'string') {
      return '‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏£‡∏±‡∏ö üôè';
    }
    
    console.log('üîç Original question:', originalQuestion);
    
    const targetPerson = detectPersonInQuestion(originalQuestion);
    console.log('üë§ Target person detected:', targetPerson);
    
    const cleanedQuestion = cleanQuestion(originalQuestion);
    console.log('üßπ Cleaned question:', cleanedQuestion);
    
    const searchQuestion = cleanedQuestion || originalQuestion;
    
    if (!db) {
      console.error('‚ùå Database not initialized');
      return '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á üôè';
    }
    
    const preferencesSnapshot = await db.collection('preferences').get();
    
    if (preferencesSnapshot.empty) {
      console.log('üì≠ No documents found in preferences collection');
      return '‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö';
    }

    console.log('üìÑ Documents in preferences collection:', preferencesSnapshot.size);

    let bestMatch = null;
    let bestScore = -Infinity;
    let bestDocId = '';
    let allMatches = [];

    // ‡∏ß‡∏ô‡∏•‡∏π‡∏õ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏∞‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà
    preferencesSnapshot.forEach(doc => {
      try {
        const data = doc.data();
        const docId = doc.id;
        
        console.log(`\nüîç Checking document: ${docId}`);
        
        const similarity = calculateSimilarity(searchQuestion, data);
        
        console.log(`üìä Similarity score: ${similarity.score}`);
        console.log(`üìù Match details:`, similarity.details);
        
        allMatches.push({
          docId,
          data,
          score: similarity.score,
          details: similarity.details
        });
        
        if (similarity.score > bestScore) {
          bestScore = similarity.score;
          bestMatch = data;
          bestDocId = docId;
          console.log(`üìà New best match: ${docId} (score: ${similarity.score})`);
        }
      } catch (docError) {
        console.error(`‚ùå Error processing document ${doc.id}:`, docError.message);
      }
    });

    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏•‡∏≥‡∏î‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡πÅ‡∏™‡∏î‡∏á top matches
    allMatches.sort((a, b) => b.score - a.score);
    console.log('\nüèÜ Top 3 matches:');
    allMatches.slice(0, 3).forEach((match, index) => {
      console.log(`${index + 1}. ${match.docId}: ${match.score} - ${match.details.join(', ')}`);
    });

    console.log(`\nüéØ Final best match score: ${bestScore}`);
    console.log('üìÑ Best match from document:', bestDocId);

    // ‡∏•‡∏î threshold ‡πÉ‡∏´‡πâ‡∏ï‡πà‡∏≥‡∏•‡∏á ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏≠‡∏ö‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
    if (bestMatch && bestScore > -1000) {
      let selectedAnswer = '';
      
      if (targetPerson === 'fern' && bestMatch.fern_answer) {
        selectedAnswer = bestMatch.fern_answer;
      } else if (targetPerson === 'nannam' && bestMatch.nannam_answer) {
        selectedAnswer = bestMatch.nannam_answer;
      } else if (targetPerson === 'both') {
        const answers = [];
        if (bestMatch.fern_answer) answers.push(bestMatch.fern_answer);
        if (bestMatch.nannam_answer) answers.push(bestMatch.nannam_answer);
        
        if (answers.length === 2) {
          selectedAnswer = answers.join('\n\n');
        } else if (answers.length === 1) {
          selectedAnswer = answers[0];
        }
      }
      
      // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏° ‡∏•‡∏≠‡∏á‡∏´‡∏≤‡∏ó‡∏≤‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏≠‡∏∑‡πà‡∏ô
      if (!selectedAnswer) {
        const fallbackAnswers = [];
        if (bestMatch.fern_answer) fallbackAnswers.push(bestMatch.fern_answer);
        if (bestMatch.nannam_answer) fallbackAnswers.push(bestMatch.nannam_answer);
        
        if (fallbackAnswers.length > 0) {
          if (targetPerson === 'fern') {
            selectedAnswer = `‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡πÄ‡∏ü‡∏¥‡∏£‡πå‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ô‡∏µ‡πâ üòÖ\n‡πÅ‡∏ï‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á: ${fallbackAnswers[0]}`;
          } else if (targetPerson === 'nannam') {
            selectedAnswer = `‡∏Ç‡∏≠‡∏≠‡∏†‡∏±‡∏¢‡∏Ñ‡∏£‡∏±‡∏ö ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Ç‡∏≠‡∏á‡∏ô‡πà‡∏≤‡∏ô‡∏ô‡πâ‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ô‡∏µ‡πâ üòÖ\n‡πÅ‡∏ï‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á: ${fallbackAnswers[fallbackAnswers.length - 1]}`;
          } else {
            selectedAnswer = fallbackAnswers[Math.floor(Math.random() * fallbackAnswers.length)];
          }
        }
      }
      
      if (selectedAnswer) {
        console.log('‚úÖ Answer found:', selectedAnswer.substring(0, 100) + '...');
        return selectedAnswer;
      }
    }

    // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡πÄ‡∏•‡∏¢ ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏ó‡∏µ‡πà‡∏ä‡∏≤‡∏ç‡∏â‡∏•‡∏≤‡∏î‡∏Ç‡∏∂‡πâ‡∏ô
    console.log('‚ùå No matching answer found');
    
    // ‡∏´‡∏≤‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î 3 ‡∏≠‡∏±‡∏ô‡∏î‡∏±‡∏ö‡πÅ‡∏£‡∏Å
    const suggestions = allMatches
      .filter(match => match.data && match.data.question)
      .slice(0, 3)
      .map(match => `"${match.data.question}"`)
      .join('\n- ');
    
    if (suggestions) {
      return `‡∏ô‡πâ‡∏≥‡∏¢‡∏±‡∏á‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÑ‡∏°‡πà‡∏≠‡∏≠‡∏Å‡∏≠‡πà‡∏≤‡∏≤ ‡∏•‡∏≠‡∏á‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà‡∏î‡∏π‡∏ô‡∏∞:\n- ${suggestions}`;
    } else {
      return '‡∏ô‡πâ‡∏≥‡∏¢‡∏±‡∏á‡∏ü‡∏±‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÑ‡∏°‡πà‡∏≠‡∏≠‡∏Å‡∏≠‡πà‡∏≤‡∏≤ ‡∏•‡∏≠‡∏á‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÉ‡∏´‡∏°‡πà‡∏î‡∏π‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö ü§î';
    }

  } catch (error) {
    console.error('‚ùå Error finding answer:', error);
    console.error('Error details:', error.message);
    return '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ñ‡∏£‡∏±‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á üôè';
  }
}

// Handle events
async function handleEvent(event) {
  try {
    if (event.type !== 'message' || event.message.type !== 'text') {
      return Promise.resolve(null);
    }

    const userMessage = event.message.text?.trim();
    if (!userMessage) {
      console.log('üìù Empty message received');
      return Promise.resolve(null);
    }
    
    console.log('üí¨ Received message:', userMessage);
    
    const answer = await findAnswer(userMessage);

    console.log('üì§ Sending reply...');
    return client.replyMessage(event.replyToken, {
      type: 'text',
      text: answer
    });
  } catch (error) {
    console.error('‚ùå Error handling event:', error);
    try {
      return client.replyMessage(event.replyToken, {
        type: 'text',
        text: '‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏Ñ‡∏£‡∏±‡∏ö ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á üôè'
      });
    } catch (replyError) {
      console.error('‚ùå Error sending error reply:', replyError);
      return Promise.resolve(null);
    }
  }
}

// Middleware
app.use('/webhook', line.middleware(config));

// Routes
app.get('/', (req, res) => {
  res.send(`
    <h1>Smart LINE Bot is running! üß†</h1>
    <p>Firebase Status: ‚úÖ Connected</p>
    <p>Project ID: ${process.env.FIREBASE_PROJECT_ID || 'Not Set'}</p>
    <p>Server Time: ${new Date().toISOString()}</p>
    <p>Features: ‚úÖ Advanced AI Matching</p>
  `);
});

app.post('/webhook', (req, res) => {
  if (!req.body || !req.body.events || !Array.isArray(req.body.events)) {
    console.error('‚ùå Invalid webhook payload');
    return res.status(400).json({ error: 'Invalid payload' });
  }
  
  Promise.all(req.body.events.map(handleEvent))
    .then((result) => {
      console.log('‚úÖ Webhook processed successfully');
      res.json(result);
    })
    .catch((err) => {
      console.error('‚ùå Webhook error:', err);
      res.status(500).json({ error: 'Internal server error' });
    });
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    firebase: db ? 'connected' : 'disconnected',
    project_id: process.env.FIREBASE_PROJECT_ID || 'Not Set',
    features: ['advanced_similarity', 'smart_matching', 'person_detection']
  });
});

// Debug endpoint
app.get('/debug', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({
        status: 'ERROR',
        firestore_connection: 'not_initialized',
        project_id: process.env.FIREBASE_PROJECT_ID || 'Not Set',
        error: 'Database not initialized'
      });
    }
    
    const preferencesSnapshot = await db.collection('preferences').limit(5).get();
    const preferencesDocs = [];
    preferencesSnapshot.forEach(doc => {
      preferencesDocs.push({ id: doc.id, data: doc.data() });
    });
    
    res.json({
      status: 'OK',
      firestore_connection: 'success',
      project_id: process.env.FIREBASE_PROJECT_ID || 'Not Set',
      features: {
        advanced_similarity: 'enabled',
        keyword_extraction: 'enabled',
        multi_dimensional_matching: 'enabled',
        smart_suggestions: 'enabled'
      },
      collections: {
        preferences: {
          size: preferencesSnapshot.size,
          sample_docs: preferencesDocs
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      status: 'ERROR',
      firestore_connection: 'failed',
      project_id: process.env.FIREBASE_PROJECT_ID || 'Not Set',
      error: error.message
    });
  }
});

// ‡πÄ‡∏û‡∏¥‡πà‡∏° endpoint ‡∏ó‡∏î‡∏™‡∏≠‡∏ö similarity
app.get('/test-similarity/:question', async (req, res) => {
  try {
    if (!db) {
      return res.status(500).json({ error: 'Database not initialized' });
    }
    
    const question = decodeURIComponent(req.params.question);
    const person = detectPersonInQuestion(question);
    const cleaned = cleanQuestion(question);
    const keywords = extractKeywords(cleaned || question);
    
    // ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Å‡∏±‡∏ö document ‡πÅ‡∏£‡∏Å
    const preferencesSnapshot = await db.collection('preferences').limit(3).get();
    const testResults = [];
    
    preferencesSnapshot.forEach(doc => {
      const data = doc.data();
      const similarity = calculateSimilarity(cleaned || question, data);
      testResults.push({
        document_id: doc.id,
        score: similarity.score,
        details: similarity.details,
        data_question: data.question,
        data_keywords: data.keywords
      });
    });
    
    res.json({
      original_question: question,
      detected_person: person,
      cleaned_question: cleaned,
      extracted_keywords: keywords,
      test_results: testResults.sort((a, b) => b.score - a.score)
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('‚ùå Unhandled error:', error);
  res.status(500).json({ error: 'Internal server error' });
});

// Handle uncaught errors
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
});

const port = process.env.PORT || 3000;
const server = app.listen(port, () => {
  console.log('üöÄ Smart Bot Server running on port', port);
  console.log('üìç Health check:', `http://localhost:${port}/health`);
  console.log('üîç Debug endpoint:', `http://localhost:${port}/debug`);
  console.log('üß™ Test similarity:', `http://localhost:${port}/test-similarity/[question]`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('üõë SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('‚úÖ Process terminated');
  });
});

process.on('SIGINT', () => {
  console.log('üõë SIGINT received, shutting down gracefully');
  server.close(() => {
    console.log('‚úÖ Process terminated');
  });
});

module.exports = app;
